package shane.leetcode.problems.xhard;

import org.junit.jupiter.api.Test;

import java.util.PriorityQueue;

import static org.assertj.core.api.Assertions.assertThat;

/**
 * TLE
 */
public class Q1526MinimumNumberOfIncrementsOnSubarraysToFormATargetArray {

    @Test
    public void test() {
        assertThat(minNumberOperations(new int[]{1, 2, 3, 2, 1})).isEqualTo(3);
        assertThat(minNumberOperations(new int[]{3, 1, 1, 2})).isEqualTo(4);
        assertThat(minNumberOperations(new int[]{3, 1, 5, 4, 2})).isEqualTo(7);
    }

    /**
     * 500 ms
     */
    @Test
    public void tle() {
        int[] arr = {8017,9008,1360,5097,755,3620,5105,6598,4290,5382,4618,5767,8864,5648,9915,6489,8449,5089,4305,9524,9094,7108,2318,5434,5508,3893,3216,3119,4405,1208,3064,2920,5095,253,2521,2011,4273,767,4425,913,4628,9211,1734,7880,801,8943,6051,607,2523,1061,1378,8186,7859,3505,8115,948,7040,4260,8299,7825,6121,2080,6074,2443,6139,4126,5673,2644,9171,8788,9723,4920,3231,7685,1240,5335,5956,2821,1597,3653,6705,7919,7006,7125,8662,8880,6634,5381,3327,4445,315,388,7755,2884,195,5853,7892,1401,225,8252,6603,7735,2870,8770,4003,7157,1042,6998,1826,1521,1073,6083,9244,4386,3727,2982,6176,2734,4266,5474,6022,8367,2537,4885,6659,1152,2967,3661,6502,2642,3545,3276,8328,1752,670,7987,5948,1390,6522,7440,9124,592,6016,7014,7700,3134,8562,6746,2707,4918,1633,507,6244,4781,4595,6827,6368,8945,7584,3288,6746,3921,6141,3985,7423,9642,7697,2402,9691,4817,9569,9812,4259,1746,419,6494,3151,1498,8818,6821,6438,6923,9123,3692,7903,6359,3163,7309,4081,5730,9303,999,5220,1158,8153,4846,8790,9801,6256,3132,2162,9074,6957,8250,4365,551,8563,6336,8389,2229,8402,6644,6087,4357,4050,1777,4125,6441,8468,4257,6947,9785,8931,4424,3482,3156,3124,9070,9992,8222,759,3492,5940,6495,7756,9391,6904,1663,7514,1692,7915,4864,3514,8208,8273,7748,9899,9373,828,3225,9528,2500,2962,5451,8728,3472,9893,351,8810,8957,8700,860,8838,282,6481,5828,4561,5306,1523,2273,5537,7376,9848,537,4418,5413,3471,9543,2754,57,6902,2286,3170,1475,4291,7284,496,69,6274,683,3320,4275,9668,233,7442,3257,5553,5448,8439,1495,7653,5454,5755,6197,5451,4390,1142,4977,4056,790,7535,7121,5868,7311,6800,5239,4892,5299,7172,199,5873,7331,6923,9147,1695,5722,6204,841,9776,6275,1906,9914,9221,5342,8883,649,9489,8169,375,9336,4707,2935,4852,1423,9536,9437,974,3128,3231,320,2624,6800,6539,9732,5834,643,6794,2560,1648,412,5703,849,7013,4679,9396,3746,9456,2919,7819,1260,2862,2592,7376,321,4940,6887,6777,3499,8594,9553,7044,8258,771,268,142,2836,526,1300,7047,7064,6571,7556,2553,9846,2636,5686,4574,8252,1307,3757,7137,112,7158,5354,8614,1637,2162,4218,6118,5044,2543,4636,7597,6846,331,763,7892,566,9685,8968,6420,6687,9629,7482,1706,7338,794,4551,1880,678,1194,5146,6232,8961,4508,8025,9102,4553,4746,8939,3930,5657,6717,6324,3204,7949,4035,6539,5809,4134,5276,8512,657,7979,6846,1266,7510,6220,5947,9163,7379,7643,1322,8353,3757,3072,5154,5705,859,7842,4515,8579,5279,1177,4303,9909,2313,1522,6456,9176,3660,987,2390,3470,4786,561,9000,38,1894,9985,6577,8512,9999,4650,2192,6035,3816,4442,1994,633,8225,8996,8238,9838,2359,3673,198,6976,1636,6586,8535,9406,5038,8040,9987,870,2375,9912,1660,4817,758,7727,1923,3537,5369,4882,8099,7245,9883,8338,8007,3927,3598,3677,2481,1567,8640,1660,3531,6267,5863,7184,5233,6300,3070,8247,1111,6269,9088,1948,9320,227,9542,9906,5200,8563,1185,54,7148,1591,7479,417,7097,690,7957,2756,1267,9773,4048,3698,395,4900,1736,8080,9884,1817,205,4849,6017,9502,7616,1768,6869,125,1147,9004,2900,4828,3556,7160,6993,6439,5608,7271,25,6482,8386,5166,257,7647,2720,6687,822,4105,3249,7217,6423,9485,1691,4951,2403,9382,4003,8250,3437,9622,9164,3871,682,9442,8427,2807,8090,1025,9212,3115,7412,2355,3989,6868,1523,4086,2386,8702,6195,5562,473,6266,7701,8139,9734,2928,492,8512,9661,5036,2221,9453,5370,4038,723,507,7260,535,8612,8962,7756,6842,4388,3710,5955,4513,2960,7390,9962,35,6492,4};
        assertThat(minNumberOperations(arr)).isEqualTo(1167897);
    }

    public int minNumberOperations(int[] target) {
        PriorityQueue<int[]> pq = new PriorityQueue<>((o1, o2) -> {
            if (o1[1] == o2[1]) return o1[0] - o2[0];
            return o2[1] - o1[1];
        }); // { index, value }
        for (int i = 0; i < target.length; i++) {
            pq.offer(new int[]{i, target[i]});
        }

        int answer = 0;
        while (!pq.isEmpty()) {
            int val = pq.peek()[1];
            int indexBefore = -2;
            while (!pq.isEmpty() && pq.peek()[1] == val) {
                int[] poll = pq.poll();
                if (indexBefore + 1 < poll[0])
                    answer++;
                indexBefore = poll[0];
                if (1 < val) {
                    pq.offer(new int[]{indexBefore, val - 1});
                }
            }
        }
        return answer;
    }

}
